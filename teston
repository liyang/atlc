#!/bin/sh
# The following script allows a distribution of any program which ends
# .tar.gz to be configured/built on a remote platform. By doing this,
# possible to spot bugs that are not apparent on a local machine. The
# script uses ssh/scp to copy the commands and should not require the
# entry of passwords. A script is created on the local machine, which
# is copied by scp/scp2 to a remote machine and executed there. Trying
# to execute the individual staments in the script via ssh takes too
# long, as the authentication needs to be repeated each time. 
########################################################################
########################################################################
# The following parameters should be set, to save specifying them on the
# command line each time you run.
########################################################################
########################################################################

USERNAME=davek                # can be overriden on the command line.
COMPILER=gcc                  # can be set to cc or wh
COMPILER_GLAGS="-Wall -O2"    # can be set on the command line
LINKER_FLAGS=-L/usr/local/lib # can be set on the command line
MAKE=make                     # can be overriden on the command line.
MAKE_OPTIONS=                 # can be changed on the commmand line
SCP=scp                       # can be changed to scp1 etc on commmand line.
SSH=ssh                       # could be changed to ssh1 etc on command line.
CONFIGURE_OUTPUT=             # chance to /dev/null if you want, but both
MAKE_OUTPUT=                  # can be set on the command line. 

########################################################################
########################################################################
# NOTHING BELOW HERE SHOULD NEED ALTERING !! Don't touch
########################################################################
########################################################################

DELETE_FILES_AFTER_USE="no"  # Don't change
TMP_NAME=

EX1a="eg #1 teston dove atlc-5.0.0"
EX1b="copies atlc-5.0.0.tar.gz to dove and builds it on dove\n"

EX2a="eg #2 teston -c '--with-threads' -M check woodpecker atlc-4.2.12"
EX2b="Builds and checks  atlc-4.2.2.tar.gz on woodpecker, configured with threads\n"

EX3a="eg #3 teston -m-j2 bluetit atlc-4.0.0"
EX3b="copies atlc-4.0.0.tar.gz to bluetit and does a parallel build\n"

EX4a="eg #4 teston -Mgmake -c--with--mpi crow atlc-4.0.0"
EX4b="copies atlc-4.0.0.tar.gz to crow and uses gmake to build with the MPICH library\n"

EX5a="eg #5 teston -u root  duke@medphys.ucl.ac.uk gcc-3.2.2"
EX5b="builds+tests gcc-3.2.2.tar.gz on duke@medphys.ucl.ac.uk using username root"

TMP_DIR=  # Don't be fooled. Don't touch it. It is not what you think!

while getopts c:m:M:trNn supplied_options
do 
  case $supplied_options in
  c)
  CONFIG_OPTIONS=$OPTARG;;
  m)
  MAKE_OPTIONS=$OPTARG;;
  n)
  CONFIGURE_OUTPUT=\>/dev/null;;
  N)
  MAKE_OUTPUT=\>/dev/null;;
  M)
  MAKE=$OPTARG;;
  t)
  TMP_DIR=$$/
  TMP_NAME=$$.;;
  r)
  DELETE_FILES_AFTER_USE="yes" ;;
  \?)
  echo "Usage: teston [options] host package\n"
  echo  "            -M name_of_make             # e.g. gmake (default = $MAKE)"
  echo  "            -c option_to_configure      # e.g --with-threads"
  echo  "            -m option_to_make           # e.g. install (default $MAKE_OPTIONS)"
  echo  "            -u username                 # username on host (default = $USERNAME)"
  echo  "            -t                          # Use a unique directory oy remote host"
  echo  "            -r                          # Removes files afterwards"
  echo  "            -n                          # Redirect output of configure to /dev/null
  echo  "            -N                          # Redirect output of make to /dev/null
  echo $EX1a  
  echo $EX1b 
  echo $EX2a  
  echo $EX2b 
  echo $EX3a 
  echo $EX3b  
  echo $EX4a  
  echo $EX4b 
  echo $EX5a  
  echo $EX5b 
  exit 1
  esac
  done
shift `expr $OPTIND - 1`

if [ $# -ne 2 ] ; then
  echo "Usage: teston [options] host package\n"
  echo  "Options are:"
  echo  "            -M name_of_make             # e.g. gmake (default = $MAKE)"
  echo  "            -c option_to_configure      # e.g --with-threads"
  echo  "            -m option_to_make           # e.g. install (default $MAKE_OPTIONS)"
  echo  "            -u username                 # username on host (default = $USERNAME)"
  echo  "            -t                          # Use a unique directory on remote host"
  echo  "            -r                          # Removes files afterwards"
  echo  "            -n                          # Redirect output of configure to /dev/null
  echo  "            -N                          # Redirect output of make to /dev/null
  echo $EX1a  
  echo $EX1b 
  echo $EX2a  
  echo $EX2b 
  echo $EX3a 
  echo $EX3b  
  echo $EX4a  
  echo $EX4b 
  echo $EX5a  
  echo $EX5b 
  exit  2
fi

REMOTE_HOST=`echo $* | awk '{print $1}'`
VER=`echo $* | awk '{print $2}'`
DATE=`date`
LOCAL_HOST=`hostname` > /dev/null

# When I sort out all my keys, the following won't be necessary, but for
# now when connecting to a machine at work, I'll use the www.ssh.com
# version of ssh, which is just called ssh2 on my machine (it is not
# linked to ssh. On my local machines, all of which run OpenSSH in one
# format or another, this is called by ssh. 
if [ $REMOTE_HOST = duke ] || [ $REMOTE_HOST = satchmo ] || [ $REMOTE_HOST = lennon ] ;  then
  SSH=ssh2 
  SCP=scp2
else
  SSH=ssh
  SCP=scp
fi
REMOTE_HOME=`$SSH $USERNAME@$REMOTE_HOST pwd`
# Create a file 'remote_test.$REMOTE_HOST' on the local machine, which we want
# executed elsewhere. 
echo "#!/bin/sh" | tee > remote-test.$TMP_NAME$REMOTE_HOST.out > remote-test.$TMP_NAME$REMOTE_HOST
echo "# Script created on $LOCAL_HOST at $DATE using 'teston' " >> remote-test.$TMP_NAME$REMOTE_HOST
echo "# to run on the remote host $REMOTE_HOST " >> remote-test.$TMP_NAME$REMOTE_HOST
echo "Output from the script created on $LOCAL_HOST at $DATE using 'teston' " >> remote-test.$TMP_NAME$REMOTE_HOST.out
#echo rm -f  $REMOTE_HOME/$REMOTE_HOST/$TMP_DIR$VER.tar >> remote-test.$TMP_NAME$REMOTE_HOST
#echo rm -fR  $REMOTE_HOME/$REMOTE_HOST/$TMP_DIR >> remote-test.$TMP_NAME$REMOTE_HOST
#echo chmod -R 644 $REMOTE_HOME/$REMOTE_HOST/$TMP_DIR$VER >> remote-test.$TMP_NAME$REMOTE_HOST
#echo rm -fR  $REMOTE_HOME/$REMOTE_HOST/$TMP_DIR$VER >> remote-test.$TMP_NAME$REMOTE_HOST
#echo rm -fR  $REMOTE_HOME/$REMOTE_HOST/$TMP_DIR$VER-build >> remote-test.$TMP_NAME$REMOTE_HOST
#echo mkdir $REMOTE_HOME/$REMOTE_HOST/$TMP_DIR >> remote-test.$TMP_NAME$REMOTE_HOST
echo cd $REMOTE_HOME/$REMOTE_HOST/$TMP_DIR >> remote-test.$TMP_NAME$REMOTE_HOST
echo gzip -d $REMOTE_HOME/$REMOTE_HOST/$TMP_DIR$VER.tar.gz >> remote-test.$TMP_NAME$REMOTE_HOST
echo tar xf $REMOTE_HOME/$REMOTE_HOST/$TMP_DIR$VER.tar >> remote-test.$TMP_NAME$REMOTE_HOST
echo mkdir $REMOTE_HOME/$REMOTE_HOST/$TMP_DIR$VER-build >> remote-test.$TMP_NAME$REMOTE_HOST
echo cd $REMOTE_HOME/$REMOTE_HOST/$TMP_DIR$VER-build >> remote-test.$TMP_NAME$REMOTE_HOST
#echo time $REMOTE_HOME/$REMOTE_HOST/$TMP_DIR$VER/configure $CONFIG_OPTIONS $CONFIGURE_OUTPUT >> remote-test.$TMP_NAME$REMOTE_HOST 2> remote-test.$TMP_NAME$REMOTE_HOST
echo $REMOTE_HOME/$REMOTE_HOST/$TMP_DIR$VER/configure $CONFIG_OPTIONS $CONFIGURE_OUTPUT >> remote-test.$TMP_NAME$REMOTE_HOST
echo time $MAKE $MAKE_OPTIONS $MAKE_OUTPUT >> remote-test.$TMP_NAME$REMOTE_HOST
if [ $DELETE_FILES_AFTER_USE = "yes" ] ; then 
  rm -r $REMOTE_HOME/$REMOTE_HOST/$TMP_DIR$VER >> remote-test.$TMP_NAME$REMOTE_HOST
fi 
chmod 755 remote-test.$TMP_NAME$REMOTE_HOST

# mkdir $REMOTE_HOST on the remote machine
$SSH $USERNAME@$REMOTE_HOST rm -fR $REMOTE_HOST/$TMP_DIR 2> /dev/null
$SSH $USERNAME@$REMOTE_HOST mkdir $REMOTE_HOST 2> /dev/null
$SSH $USERNAME@$REMOTE_HOST mkdir $REMOTE_HOST/$TMP_DIR 2> /dev/null

# Copy via scp/scp2 the script file in addition to the package
# (somename.tar.gz) to the remote machine.

$SCP -p remote-test.$TMP_NAME$REMOTE_HOST $USERNAME@$REMOTE_HOST:$REMOTE_HOST/$TMP_DIR
$SCP $VER.tar.gz $USERNAME@$REMOTE_HOST:$REMOTE_HOST/$TMP_DIR
 

# Execute the script on the distant machine.
cat remote-test.$TMP_NAME$REMOTE_HOST >> remote-test.$TMP_NAME$REMOTE_HOST.out
$SSH $USERNAME@$REMOTE_HOST $REMOTE_HOST/$TMP_DIR/remote-test.$TMP_NAME$REMOTE_HOST | tee -a remote-test.$TMP_NAME$REMOTE_HOST.out
END_DATE=`date`
echo "Script finished at $END_DATE using 'teston' " | tee -a remote-test.$TMP_NAME$REMOTE_HOST.out

# Clean up the local file after ourselves. 
if [ DELETE_FILES_AFTER_USE = "yes" ] ; then 
  rm remote-test.$TMP_NAME$REMOTE_HOST
fi
